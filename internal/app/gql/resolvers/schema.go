package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"

	"github.com/palomachain/paloma-cdp/internal/app/gql"
	"github.com/palomachain/paloma-cdp/internal/app/gql/model"
	"github.com/palomachain/paloma-cdp/internal/pkg/liblog"
	dbmodel "github.com/palomachain/paloma-cdp/internal/pkg/model"
	"github.com/uptrace/bun"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Bars is the resolver for the bars field.
func (r *queryResolver) Bars(ctx context.Context, symbolName string, resolution string, from int32, to int32) ([]model.Bar, error) {
	if len(symbolName) == 0 {
		return nil, gqlerror.Errorf("symbolName is required")
	}

	return nil, nil
}

// Symbol is the resolver for the symbol field.
func (r *queryResolver) Symbol(ctx context.Context, symbolName string) (*model.LibrarySymbolInfo, error) {
	if len(symbolName) == 0 {
		return nil, gqlerror.Errorf("symbolName is required")
	}

	var m dbmodel.Symbol
	if err := r.Db.NewSelect().
		Model(&m).
		Relation("Exchange").
		Where("s.name = ?", symbolName).
		Scan(ctx); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}

		slog.Default().ErrorContext(ctx, "failed to get symbol", "error", err)
		return nil, gqlerror.Errorf("symbol not found, see request ID %s", liblog.RequestID(ctx))
	}

	return &model.LibrarySymbolInfo{
		Type:                 cSymbolType,
		Session:              cSymbolSession,
		Timezone:             cSymbolTimezone,
		Minmov:               cSymbolMinMov,
		Pricescale:           cSymbolPricescale,
		HasIntraday:          true,
		VisiblePlotsSet:      cSymbolVisiblePlotsSets,
		HasWeeklyAndMonthly:  true,
		SupportedResolutions: supportedResolutions,
		VolumePrecision:      cSymbolVolumePrecision,
		DataStatus:           cSymbolDataStatus,
	}, nil
}

// Symbols is the resolver for the symbols field.
func (r *queryResolver) Symbols(ctx context.Context, userInput string, exchange *string, symbolType *string) ([]model.Symbol, error) {
	if len(userInput) == 0 {
		return nil, gqlerror.Errorf("userInput is required")
	}

	var m []dbmodel.Symbol
	q := r.Db.NewSelect().
		Model(&m).
		Relation("Exchange").
		Where("? LIKE ?", bun.Ident("s.name"), fmt.Sprintf("%%%s%%", userInput))
	if exchange != nil && len(*exchange) > 0 {
		q = q.Where("? = ?", bun.Ident("exchange.name"), *exchange)
	}

	if err := q.Scan(ctx); err != nil {
		if err != sql.ErrNoRows {
			slog.Default().ErrorContext(ctx, "failed to search symbols", "error", err)
			return nil, gqlerror.Errorf("failed to search symbols, see request ID %s", liblog.RequestID(ctx))
		}
	}

	rs := make([]model.Symbol, len(m))
	for i, v := range m {
		rs[i] = model.Symbol{
			Symbol: v.DisplayName,
			Type:   cSymbolType,
		}
	}

	return rs, nil
}

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
